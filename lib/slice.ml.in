type t = S.t Slice.t

open Slice

let make ?(off= 0) ?len buf =
  let len = match len with
    | Some len -> len
    | None -> S.length buf - off in
  if len < 0
  || off < 0
  || off > S.length buf - len
  then invalid_arg "Slice.make";
  Slice.unsafe_make ~off ~len buf

let empty = unsafe_make ~off:0 ~len:0 S.empty
let length { len; _ } = len
let get { off; buf; _ } idx = S.get buf (off + idx)
let get_int8 { off; buf; _ } idx = S.get_int8 buf (off + idx)
let get_uint8 { off; buf; _ } idx = S.get_uint8 buf (off + idx)
let get_uint16_ne { off; buf; _ } idx = S.get_uint16_ne buf (off + idx)
let get_uint16_le { off; buf; _ } idx = S.get_uint16_le buf (off + idx)
let get_uint16_be { off; buf; _ } idx = S.get_uint16_be buf (off + idx)
let get_int16_ne { off; buf; _ } idx = S.get_int16_ne buf (off + idx)
let get_int16_le { off; buf; _ } idx = S.get_int16_ne buf (off + idx)
let get_int16_be { off; buf; _ } idx = S.get_int16_be buf (off + idx)
let get_int32_ne { off; buf; _ } idx = S.get_int32_ne buf (off + idx)
let get_int32_le { off; buf; _ } idx = S.get_int32_le buf (off + idx)
let get_int32_be { off; buf; _ } idx = S.get_int32_be buf (off + idx)
let get_int64_ne { off; buf; _ } idx = S.get_int64_ne buf (off + idx)
let get_int64_le { off; buf; _ } idx = S.get_int64_le buf (off + idx)
let get_int64_be { off; buf; _ } idx = S.get_int64_be buf (off + idx)
let set { off; buf; _ } idx v = S.set buf (off + idx) v
let set_int8 { off; buf; _ } idx v = S.set_int8 buf (off + idx) v
let set_uint8 { off; buf; _ } idx v = S.set_uint8 buf (off + idx) v
let set_uint16_ne { off; buf; _ } idx v = S.set_uint16_ne buf (off + idx) v
let set_uint16_le { off; buf; _ } idx v = S.set_uint16_le buf (off + idx) v
let set_uint16_be { off; buf; _ } idx v = S.set_uint16_be buf (off + idx) v
let set_int16_ne { off; buf; _ } idx v = S.set_int16_ne buf (off + idx) v
let set_int16_le { off; buf; _ } idx v = S.set_int16_ne buf (off + idx) v
let set_int16_be { off; buf; _ } idx v = S.set_int16_be buf (off + idx) v
let set_int32_ne { off; buf; _ } idx v = S.set_int32_ne buf (off + idx) v
let set_int32_le { off; buf; _ } idx v = S.set_int32_le buf (off + idx) v
let set_int32_be { off; buf; _ } idx v = S.set_int32_be buf (off + idx) v
let set_int64_ne { off; buf; _ } idx v = S.set_int64_ne buf (off + idx) v
let set_int64_le { off; buf; _ } idx v = S.set_int64_le buf (off + idx) v
let set_int64_be { off; buf; _ } idx v = S.set_int64_be buf (off + idx) v

let blit a b =
  let len = Int.min a.len b.len in
  S.blit a.buf ~src_off:a.off b.buf ~dst_off:b.off ~len:len

let fill { off; len; buf; } ?off:(off'= 0) ?len:len' chr =
  let len' = match len' with
    | Some len' -> len'
    | None -> len - off' in
  S.fill buf ~off:(off + off') ~len:len' chr

let sub t ~off ~len = Slice.sub t ~off ~len
let shift t n = Slice.shift t n
let is_empty t = Slice.is_empty t

let sub_string { Slice.buf; off; _ } ~off:off' ~len =
  let dst = Bytes.create len in
  S.blit_to_bytes buf ~src_off:(off + off') dst ~dst_off:0 ~len;
  Bytes.unsafe_to_string dst

let to_string { Slice.buf; off= src_off; len } =
  let dst = Bytes.create len in
  S.blit_to_bytes buf ~src_off dst ~dst_off:0 ~len;
  Bytes.unsafe_to_string dst

let of_string str =
  let off = 0 and len = String.length str in
  Slice.unsafe_make ~off ~len (S.of_string str)

let string ?(off= 0) ?len str =
  let len = match len with 
    | None -> String.length str - off 
    | Some len -> len in
  Slice.unsafe_make ~off:0 ~len (S.string ~off ~len str)

let overlap ({ buf= buf0; _ } as a) ({ buf= buf1; _ } as b) =
  match S.overlap buf0 buf1 with
  | None -> None
  | Some (len, 0, 0) ->
      if a.off >= b.off && a.off < b.off + b.len
      then let offset = a.off - b.off in Some (len, 0, offset)
      else if b.off >= a.off && b.off < a.off + a.len
      then let offset = b.off + a.off in Some (len, offset, 0)
      else None
  | Some _ -> assert false
